# -*- coding: utf-8 -*-
"""lab004.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aAW7PyOxWox_frA3Qpgp8S-6yNZbC296

## 1 Dimension
"""
import numpy as np
# f(x) = |x|
def f1(xx):
  x= xx[0]
  if x > 0 or x == 0:
    fv = x
    subgrad = 1
  else:
    fv = -x
    subgrad = -1
  return fv, np.array([subgrad])

# f(x) = max{-2x, x+3, |x-1|} = max{-2x, x+3}
def f2(x):
    a = -2 * x
    b = x + 3

    if a >= b:
      f2 = a
      subgrad = -2
    else:
      f2 = b
      subgrad = 1

    return f2, subgrad

# f(x) = max{x², x+1, -2x}
def f3(x):
  a = x * x
  b = x + 1
  c = -2 * x

  if x < -2:
      f3 = a
      subgrad = 2 * x
  elif -2 <= x <= -1/3:
      f3 = c
      subgrad = -2
  elif -1/3 < x <= (1 + 5 ** 0.5)/2:
      f3 = b
      subgrad = 1
  elif x > (1 + 5 ** 0.5)/2:
      f3 = a
      subgrad = 2 * x

  return f3, subgrad

"""## 2 Dimensions"""

# f(x1,x2) = |x1 - 1| + |x2 - 2|
def f4(x):
  x=np.array(x)

  fv = abs(x[0] - 1) + abs(x[1] - 2)

  subgrad = [0,0]

  if x[0] > 1:
    subgrad[0] = 1
  else:
    subgrad[0] = -1

  if x[1] > 2:
    subgrad[1] = 1
  else:
    subgrad[1] = -1
  
  #print(fv, np.array(subgrad))
  return fv, np.array(subgrad)

# f(x1,x2) = max{x1-x2, -x1+x2, x1+x2}
def f5(x):
  a = x[0]-x[1]
  b = -x[0]+x[1]
  c = x[0]+x[1]

  f5 = max(a, b, c)

  if a == f5:
    subgrad = [1, -1]
  elif b == f5:
    subgrad = [-1, 1]
  else:
    subgrad = [1, 1]

  return f5

# min distance to the [−1,1] square
# f(x) = min ||x-y||_2, C = {y \in \mathbb{R}^2: ||y||_{\infty} <= 1}
# y as x projection over C
# when x is in C, x = y, f = 0 and subgrad=[0,0]
# else f > 0 and f is differentiable
def f6(x):
  y=[0,0]
  if x[0] < -1:
      y[0] = -1
  elif x[0] > 1:
      y[0] = 1
  else:
      y[0] = x[0]

  if x[1] < -1:
      y[1] = -1
  elif x[1] > 1:
      y[1] = 1
  else:
      y[1] = x[1]

  dx = x[0] - y[0]
  dy = x[1] - y[1]
  f6 = (dx * dx + dy * dy) ** 0.5

  if f6 == 0:
    subgrad = [0,0]
  else:
    subgrad = [dx / f6, dy / f6]

  return f6, subgrad

#x1 = (0.5, 0.5)
#f6(x1)

#x2 = (2.0, 0.0)
#f6(x2)

#x3 = (1.0, 0.5)
#f6(x3)

"""## 5 Dimensions"""

# f(x1,x2,x3,x4,x5) = max{|x1|,|x2|,|x3|,|x4|,|x5|}
def f7(x):
  f7 = max(abs(x[0]), abs(x[1]), abs(x[2]), abs(x[3]), abs(x[4]))
  return f7

# f(x1,x2,x3,x4,x5) = sum_{i=1}^5 max{xi^2, |xi|}
def f8(x):
  f8 = 0
  for i in range(5):
    if x[i] ** 2 > abs(x[i]):
      f8 += x[i] ** 2
    else:
      f8 += abs(x[i])
  return f8

"""## Higher Dimensions"""

# f(x) = \sum_{i=1}^{20} w_i|xi|, wi \in [1,3] fixed random weights
import random

weights = [random.uniform(1, 3) for _ in range(20)]

def f9(x):
  f9 = 0
  for i in range(20):
    if x[i] >= 0:
      abs_xi = x[i]
    else:
      abs_xi = -x[i]
    f9 += weights[i] * abs_xi
  return f9

# f(x) = ||Ax-b||_2 + \lambda||x||_1
# not sure
def f10(x, A, b, lamb):
  m = 50
  n = 100
  Ax = []

  for i in range(m):
      soma = 0
      for j in range(n):
          soma += A[i][j] * x[j]
      Ax.append(soma)

  norm2 = 0
  for i in range(m):
      diff = Ax[i] - b[i]
      norm2 += diff * diff
  norm2 = norm2 ** 0.5

  norm1 = 0
  for i in range(n):
      xi = x[i]
      if xi >= 0:
        norm1 += xi
      else:
        norm1 -= xi

  f10 = norm2 + lamb * norm1

  return f10